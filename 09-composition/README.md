# Урок 9 Композиция функций

- 09.01 Задача на композицию функций
- 09.02 Решение 1. Вложенные case
- 09.03 Решение 2. Каждый case в отдельной функции
- 09.04 Решение 3. Использование исключений
- 09.05 Решение 4. Монада Result и оператор bind
- 09.06 Решение 5. Pipeline
- 09.07 Решение 6. do-нотация
- 09.08 Что такое монада?


### 09.01 Задача на композицию функций

Это последний урок данного курса. Здесь будем собирать в единое целое все свои
новые знания, и применим свои новые знания на практике.

Поднимимся чуть выше уровня язка, на более высокий, абстрактный уровень.
Поговорим на текие темы как абстракция, композиция и т.д.

Абстракция - это мощный инструмент в руках разработчика и архитектора.
абстракция это про то, чтобы взять что-то сложное, некую сложную функциональность
и представить её упрощенно, "спрятать за фасадом" - за неким API. Причем этот
API может быть очень простым и понятным, тогда как конкретная его реализация
может быть очень сложной и запутанной. Основная идея здесь упростить и облегчить
понимание и использование тяжелых для быстрого восприятия и понимания вещей.
Сложное абстрагируем упрощенным "фасадом", облегчая понимание того как им
пользоваться.

Компонент - это некий отдельный элемент абстракции, имеющий сложную реализацию
и упрощенный для понимания "фасад"(API) Компонеты как строительные блоки для
построения больших и сложных систем. Продумывание архитектуры системы - это
про то что беруться компоненты и соединяются друг с другом в разных пропорциях.
Хорошо продуманные компоненты будет легко комбинировать с друг с дрогом.
Когда компоненты комбинируются легко - говорят "хорошая абстракция".
Плохая абстракция - это когда комбинировать компоненты друг с другом либо
вообще не получается либо их комбинации "разваливаются". Плохая абстракция -
признак того, что реализуемые вещи не достаточно хорошо продуманы.

- В ООП компонентом является обьект.
- В ФП компонентом является либо
  - одна отдельная функция, тогда фасадом(API) такого компонента будут
    аргументы функции.
  - либо набор функций обьединённых в некий модуль
    например модуль Enum - обьединяющий функции для работы с коллекциями
    то есть и модуль тоже можно воспрнимать как своего рода фасад за которым
    прячется некая сложность реализации доступной функциональности.


#### о проектировании функций и их компоновке

- о том как проектировать функции так, чтобы их было удобно друг с другом компоновать
- какие могут возникнуть трудности и проблемы


Вот пример простейших функций.
(тривиальный случай)
```elixir
defmodule Composition do
  def f1(a) do
    a + 1
  end

  def f2(a) do
    a + 10
  end
end
```

эти две функции соединяются очень просто:
(пример тривиального соединения)
```elixir
iex> alias Composition, as: C
Composition

iex> C.f1(10)
11

iex> 10 |> C.f1 |> C.f2
```

пример первого не тривиального случая - у функции два рагумента

```elixir
  def f3(a, b) do
    a + b
  end
```

```elixir
iex> r C
{:reloaded, [Composition]}
iex> 10 |> C.f1 |> C.f2 |> C.f3(10)
31                      #       ^^ 2й аргумент(1й идёт через pipe)
```

еще один не тривиальный случай - возращаемое значение не число а кортеж

```elixir
  def f4(a) do
    {:ok, a + 1}
  end
```

есть такая ф-я последняя в цепочки - нет проблем

```elixir
iex> 10 |> C.f1 |> C.f2 |> C.f3(10) |> C.f4()
{:ok, 32}
```

а вот если f4 нужно разместить между другими функциями - нужен некий адаптер

```sh
iex> 10 |> C.f1 |> C.f2 |> C.f3(10) |> C.f4() |> C.f1()
** (ArithmeticError) bad argument in arithmetic expression: {:ok, 32} + 1
    :erlang.+({:ok, 32}, 1)
    composition.exs:3: Composition.f1/1
    iex:8: (file)
```

elem - вытащить значение кортежа по заданному индексу (начиная с 0)
```elixir
iex> 10 |> C.f1 |> C.f2 |> C.f3(10) |> C.f4() |> elem(1) |> C.f1()
33
```
то есть для того чтобы соединить между собой две функции f4 и f1
пришлось использовать доп. ф-ю elem()


> функция возращает разные типы значений.

как быть когда есть функция f5 которая может возращать разные структуры
либо кортежа либо просто атом :error

```elixir
  def f5(a) when a < 10 do
    {:ok, a + 1}
  end

  def f5(a) do
    :error
  end
```

Уже здесь при создании композиции функций и начинаются проблемы

к тому же внутри функций могут имется side-effect-ы(побочные действия), которые
просто посмотрев на "фасад"(цепочку вызова функций) можно и не отследить и
вообще не узнать о их существовании:
```elixir
  def f6(a) do
    drop_database() # side effect what changes something somewhere in the outside
    a + 42
  end
```

В развитых Функциональных Языках
таких как Haskell для соединения(композиции) всяких разных функций есть всякие
разные приспособы. например в Elixir есть оператор pip (|>), тогда как в Haskell
таких разных штук-приспособ довольно много. Можно например на лету как-то
преобразовывать вывод функций так чтобы его можно было перенаправлять в другую
функцию. Есть такие вещи как
- апликативные функкторы
- монады
- монадные трансформеры

Это есть в Haskell(ФП языке) но подобных вещей нет в Elixir.

Теперь осознав проблему, можно перейти к формулированию некой практической
задачи. Посмотреть на примере, как реализовать решение через функции так, чтобы
было эти функции было удобно компоновать двуг с другом.

Обсудим и попробуем 6 разных реализации:

- Решение 1. Вложенные case
- Решение 2. Каждый case в отдельной функции
- Решение 3. Использование исключений
- Решение 4. Монада Result и оператор bind
- Решение 5. Pipeline
- Решение 6. do-нотация

То есть у нас будут одни и те же функции
(которые одинаково называются и делают примерно одно и тоже)
и мы будем учиться проектировать их под разные способы компоновки
и соответственно по разному их затем компоновать.

Сначала мы опимем задачу которую будет решать и реализовывать,
а дальше используя разные способы компоновки будем решать ей каждый раз заново.

и в конце посомотрим на новый полученный опыт и придём к пониманию того,
какие способы стоит запомнить и использовать в своей практике, а какие можно
будет отбросит, просто зная что такое существует.


### постановка практической задачи(формулировка)

- есть некий веб-сервис
  (это не удивительная для современного прогроммирования задача.)
- в API на вход приходит некий json документ
- наш веб-сервис - это интернет магазин продающий книги

покупатель может
- зарегистрироваться в нашем интернет магазине,
- указать адрес доставки
- заказать некие книги(положить в корзину)
- мы этот заказ обрабатываем, собираем книги и привозим покупателю.

на каком-то этапе в наш веб-сервис приходит вот такой вот json:

```json
{
  "user": "Attis",
  "address": "Freedom str 7/42 City Country",
  "books": [
    {"title": "Domain Modeling Made Functional", "author": "Scott Wlaschin"},
    {"title": "Distributed systems for fun and profit", "author": "Mikito Takada"},
    {"title": "Adopting Elixir", "author": "Marx, Valim, Tate"},
  ]
}
```

этот Json описывает заказ
обязаности нашего сервиса при приёмке этого документа:
- провалидировать валидность Json-данных и соответствие схеме
- проверить действительно ли указанный покупатель(user) известен системе(зареган)
- проверить что покупатель аутентифицирован и авторизован
- провалидировать валидность адреса
- пройтись по списку книг и проверить их наличие
- после выполнения всех проверок - собрать обьект Order(Заказ)
  и отправляем его по системе на обработку, оплату и доставку.


короче задача
- провалидировать входящие данные
- создать валидный обьект типа Order
  (который по ходу дела опишем в виде структур)

шаги нужные для выполнения валидации:
- validate json document
- volidate user
- volidate address
- volidate book (list)
- make order

для упрощения Json у нас будет в виде Map, то есть упрощенно считаем что у нас
уже есть подключенная либа преобразующая json(строку) в Map

всё вышеописанное это будем описывать(реализовывать) в виде функций:

продумываем наши основные функции для требуемой функциональности
(стразу через спецификацию типов @spec)

```elixir
@spec validate_incomming_data(map()) :: {:ok, map()} | {:error, :invalid_incomming_data}
@spec validate_user(name :: String.t()) :: {:ok, User.t()} | {:error, :user_not_found}
@spec validate_address(String.t()) :: {:ok, Address.t()} | {:error, :invalid_address}
@spec validate_book(map()) :: {:ok, Book.t()} | {:error, :book_not_found}
@spec create_order(User.t(), Address.t(), [Book.t()]) :: Order.t()
```

- User - для упрощения будет иметь только имя без всяких там
  id, first_name, last_name. Имена считаем уникальным идентификатором.

в "идеальном мире" (happy path) композиция функций была бы такая:

```elixir
json
|> validate_incomming_data()
|> validate_user()
|> validate_address()
|> validate_book()     # list!
|> create_order()
```
просто все наши функции соединяем через оператор pipe

но увы у нас в системе и коде возможны ветвления
```elixir
{:ok, map()} | {:error, :invalid_incomming_data}
```
а оператор pipe это вообще не про ветвление

Весь этот урок мы и будем думать как реализовать соединение наших функций так
чтобы это было и красиво и понятно.



