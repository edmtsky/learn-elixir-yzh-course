## 09_08 Что такое монада? (Теория)

в 7м уровке уже разбирали прям самую базу ФП, и то из каких элементов оно
состоит.

Копнём функциональное программирование(ФП) глубже:
(поговорим о следующем по глубине слое ФП, в этом слое есть:

- Монады
- Апликативные функторы
- Каррирование
- Монадные трансформеры


Элементы ФП (из 7го урока)

- Иммутабельные данные (Immutability)
- Рекурсия, как основной способ итерации по коллекциям
- Ф-ии высшего порядка (HOF) (ф-и можно передавать как значения)
- Анонимные ф-и (замыкания, лямбды)
- Алгебраические типы данных (ADT) (конструирование типов из других типов)
- Сопоставление с образцом (Patern Matching)
- Ленивые вычисления (Lazy Evaluation)
- Автоматический вывод типов (Type Inference) (Это про статическую типизацию)
- Чистые ф-ии и контроль побочных эффектов (Есть в Haskell)

в Эликсир есть всё кроме последних двух пунктов.


Что такое ФП?
код который **в основном** состоит из элментов ФП.
Хотя в нём могут быть не-ФП элементы:
- мутабельная память
- циклы for вместо рекурсии
- побочные эффекты

Дело в пропорции тех и других элементов


### выходим на следующий уровень теории об ФП, что в ФП есть еще?

Монада - это значение, обёрнутов в некий контекст
```elixir
{:ok, book} =
  Bookshop.Controller.validate_book(data)
```
Значение book обёрнуто в контекст `{:ok,...}`


```elixir
{:error, :book_not_found} =
  Bookshop.Controller.validate_book(data)
```
Значение :book_not_found обёрнуто в контекст {:error, ...}


#### Монада Result
Такой тип данных:

```elixir
{:ok, sucessful_value} | {:error, error_value}
```
Это монада **Result** - одна из самых популярных монад, и встречается во многих
ФП языках.

Eсть почти во всех ФП языках и во многих не ФП языках:
пример того как эта монада Result обозначается в разных ЯП

- Haskell `Result e t`
- OCaml   `('e, 't) result`
- Rust    `Result<T,E>`
- Scala   `Either[E,T]`

в Эликсир конкретного зарезервированного слова или типа данных под монаду Result
нет


#### Монада Maybe
эта монада гооврит о том, что значет либо есть либо его вообще нет

Тоже встречается часто:
```elixir
iex> m = %{a: 42}
iex> Map.fetch(m, :a)    # библиотечная функция Эликсир "достать значение по ключу"
{:ok, 42}

iex> Map.fetch(m, :b)
:error                   # когда такого ключа нет в Map
```

описывается типом:
```
{:ok, value} | :no_value
```

то есть по сути монада `Maybe` похожа на монаду `Result`, только у неё в
случае ошибки возращается некий "сигнал" что значения нет - ошибка


#### Монада Future

эта монада про запуск некого асинхронного вычисления,
и после запуска выдаётся не сам результат вычисления.
ну например http-клиент отправляющий Http-Запрос на удалённый сервер

```elixir
iex> future_value = Task.async(fn() -> 42 end)
#                   ^(1)       ^^^^^^^^^^^^^^(2)
%Task{                   # это значение которое отдаёт вызов Task.async
  owner: #PID<0.107.0>,
  pid: #PID<0.112.0>,
  ref: #Reference<...>
}

iex> Task.await(future_value)
42
```
- 1. Task - этом одуль позволяющий запускать асинхронные(отложенные) вычисления
- 2. фун-я возращающая результат которую мы здесь и запускаем асинхронно.
- future_value - здесь это тоже монада и называется она монада `Future`



#### Оператор Bind
это оператор для создания композиции(связывания) ф-ий
мы примерняли его на практике в solution-4

```elixir
defmodule FP do
  @type successful() :: any()
  @type error() :: any()
  @type monada_result() :: {:ok, successful() | {:error, error()}}
  @type m_fun() :: (any() -> monada_result())

  @spec bind(m_fun(), m_fun()) :: m_fun()
  #          arg1     arg2        return value
  def bind(f1, f2) do
    fn args ->
      case f1.(args) do
        {:ok, result} -> f2.(result)
        {:error, error} -> {:error, error}
      end
    end
  end
```
m_fun() - это тип обозначающий функцию, которая возращает монаду `Result`
таким образом здесь наш bind принимает две функции типа m_fun() и возращает
новую функцию типа m_fun()

то как мы применяли bind в solution-4
```elixir
  def handle(data) do
    f =      # (1)
      FP.bind(&step_validate_incoming_data/1, &step_validate_user/1)
      |> FP.bind(&step_validate_address/1)
      |> FP.bind(&step_validate_books/1)
      |> FP.bind(&step_create_order/1)

    f.(data) # (2)
  end
```
- 1. связывание пяти функций в одну новую
- 2. вызов вычисления(полученной функции - композиции связанных ф-ий)

и здесь важно понимать что такой bind работает только с функциями которые
возращают монаду Result и ничем больше.

Оператор Bind
- наша ф-я работает только с монадой Result
- сделать похожую ф-ю для монады Maybe достаточно легко
- сделать связывание(bind) для монада Future уже сложнее


#### Оператор bind - создание связывания(bind) для монада Future

Допустим у нас есть несколько асинхронных зыпросов:
допустим у нас микросервисная архитектура и нам нужно отправить три запроса
в разные сервисы дождаться ответов от каждого из них и уже дальше что-то
с этим ответами сделать:

```elixir
future1 = request_service_1()
value1 = Task.await(future1)   # блокируемся пока не придёт ответ

future2 = request_service_2()
value2 = Task.await(future2)

future3 = request_service_3()
value3 = Task.await(future3)
```
это будет работать но будет медленно.


пример реализации bind_async для такого сценария
(суть работы примерно такая же как обычный bind для монад Result или Maybe

```elixir
bind_async(&request_service_1/0, &request_service_2/0)
|> bind_async(&request_service_3/0)
```
- простейшая реализации - с блокировкой вызывать каждый запрос по очереди
- сложная реализация - с паралельными вызовами всех запросов
(будем это реализовывать во 2й части курса про OTP и многопоточку)



#### что общего у всех монад?

- приходим к тому что есть bind каждый из которых работает со своими монадами:
  Result, Maybe, Future

вопрос: почему эти три вещи обьединили в одно целое и назвали монадами?
Что у них общего?

Общее у них операция bind(связывание) - возможность единообразно делать
композицию функций, которые работает со всеми этими видами монад.

В Haskell оператор bind:
```haskell
validate_book             // "связывание" функиий возвращающих монаду Result
>>= buy_book
>>= deliver_book

request_service_1         // "связывание" функиий возвращающих монаду Future
>>= request_service_2
>>= request_service_3
```

В эликсире такого оператора `bind` нет, но его можно реализовать самому:
- в Эликсир есть протоколы и можно было бы
  для разных типов данных (для монада Result, Maybe, Future) реализовать свой
  протокол, на основе которого затем функция bind работала.
- есть готовое решение для подобных вещей - библиотека Monad:
  https://hexdocs.pm/monad/Monad.html

В общем если кратко и по сути -
монады это про то как одним универсальным способом связывать функции между собой
то есть про то, как делать композицию ф-ий.
(то что мы делали весь 9й урок - брали разные свои функции, которые возращают
разные - не совместимые значения, и пытались выстроить из них цепочку вызовов с
возможностью останавливаться в месте где возникла ошибка)


#### Другие операции над монадами

рассмотрим какие разные ф-ии могут быть, и какие операторы могут понадобиться
для их соединения

пусть
- v - для обозначения некого обычного значения
- M(v) - значение обёрнутое в некий тип монады (не только в монада Result)
- `::` - ф-я возращает а дальше тип или значение

> варианты того какими могут быть фун-ии
- f1(v) :: v
- f2(v) :: M<v>
- f3(M<v>) :: v
- f4(M<v>) :: M<v>

словами
- фун-я принимает простое значение и возращает простое значение
- ф-я принимает простое значение и возращает монаду
  (именно такими яв-ся наши функции валидации в 9м уроке)
- ф-я принимает монаду - возращает простое значение
- принимает монаду и возращает монаду

теперь скажем есть потребность в композиции которая бы умела соединять(bind)
любой из этих типов функций с другим типом функций.

в Haskell для это есть разный набор операторов:
(когда все вышеописанные типы фун-ий нужно комбинировать(bind) между собой)

Возможная реализация на элексире:
- f1 |> f1
- f2 >>= f2                      # через фун-ию bind
- f3 |> wrap_into_monad |> f3    # своя ф-я wrap_into_monad анагл return из Haskell
- f4 |> f4

Haskell:
- `f1 . f2`          - это оператор "точка" соединяющий функции 1го типа (f1)
- `f2 >>= f2`        - оператор bind для соединения ф-ий 2го типа  (f2)
- `f3 . return . f3` - ф-я return "поднимает значение" - по простому оборачивает
                       в монаду
- `f4 >> f4`         - случай монада на входе монада на выходе


то есть такой набор операторов позволит компоновать друг с другом любые ф-ии
выстраивя нужную нам цепочку функций

поэтому чисто теоритически любая нами написанная программа может свестись к
цепочке вида:

```haskell
f1 >== f2 . f3 >> f4 >>= f5 . f6
```
это функции разного типа(см выше) которые соеденены друг с другом через
разные операторы

другими словами можно сказать что, чисто теоритически вся программа - это одна
большая, длинная цепочка(композиция) фун-й

- такая цепочка представляет собой happy path
- ветвления будут скрыты в операторах композиции

но всё это будет работать только для функций принимающих только 1 аргумент
на практике обычно нужно несколько аргументов.
вот мы и выходим на "каррирование"


#### каррирование (поддержка ф-й с несколькими аргументами)

- функцию f/3 (с арностью 3 т.е. принимающую 3 аргумента) можно представить
как функцию f/1 возращающую f/2

- ф-ю f/2 можно представить как f/1 возращающую f/1

пример этого в реальном рабочем Эликсировском коде:
```elixir
def f2(a) do
  fn(b) -> a + b end
end

def f3(a) do
  fn(b) ->
    fn(c) -> a + b + c end
  end
end
```

```elixir
iex> f1 = f2(1)        # вызываем ф-ю f2 передавая один аргумент = 1, получая
                       # на выходе другую функцию от 1го аргумента и кладём её
                       # в переменную f1
iex> res = f1.(2)      # получение результата вызываем ф-ю от 1го аргумента

iex> res = f2(1).(2)   # тоже самое как выше но в одну строку(цепочку)


iex> f2 = f3(1)        # получаем ф-ю от 2х аргументов
iex> f1 = f2.(2)       # получаем ф-ю от 1го аргумента
iex> res = f1.(3)      # получаем результат аналог  fn (a, b, c) -> a+b+c end

iex> res = f3(1).(2).(3) # тоже самое одной строкой
```

другими словами в Эликсире каррирование возможно и работает.

Каррирование

- Каррирование позволяет представить любую ф-ю как функцию от 1го аргумента.
- в Эликсир это возможно, но не применяется на  практике т.е. не юзабильно
- в Хаскель это работает автоматически для любой функции
  поэтому удобно и юзабильно на практике
- каррирование позволяет применять все способы композиции ко всем фун-ям

В Haskell каждая функция каррируется автоматическии - что позволяет вызвать
функцию от любого кол-ва аргументов.
- как я понимаю авто каррирование в хаскель когда в скажем в ф-ю от 4х арг-ов
  передано только 3 то автоматом создаться функция для вызова на недостающем
  4м аргументе.


теперь, имея возможность делать композицию любых фун-ий с любыми монадными
значениями и имея каррирование, мы можем уже на практике получить длинную
цепочку скомпонованных функций представляющих собой программу.

#### еще одна тонкость с монадными значениями

на этом этапе можно получить монады вложенные друг в друга.

На пути композиции рано или поздно мы столкнёмся с монадами, которые
вложены друг в друга:

- `Result<Maybe<v>>`
- `Future<Result<v>>`

И здесь возникает потребность преобразовывать одни монады в другие.
Монадные трансформеры - это то что помогает решить эту задачу.



#### Монадные трансформеры

мы уже имели дело с таким монадным трансформеров на практике в 9м уроке.

Ф-я FP.sequence/1 яв-ся монадным трансформером.

```elixir
# module FP
@spec sequence([monada_result()]) :: {:ok, [successful()]} | {:error, error()}
```
описание используемых типов в этой спеке
```elixir
  @type successful() :: any()
  @type error() :: any()
  @type monada_result() :: {:ok, successful() | {:error, error()}}
  @type m_fun() :: (any() -> monada_result())
```

- sequence - это ф-я принимающая список из монад (тип monada_result()) и
возращающая монаду Result, но при успехе значение которой - это список успешных
значений из списка входных монад.

то как мы эту функцию использовали на практике:

```elixir
iex>  [
        {:ok, :book1},
        {:ok, :book2},
        {:ok, :book3}
      ] |> FP.sequence()
{:ok, [:book_3, :book_2, :book_1]}    # при успехе когда нет ни одной ошибки

iex>  [
        {:ok, :book1},
        {:errork, :book_not_found},
        {:ok, :book3}
      ] |> FP.sequence()
{:error, :book_not_found}             # когда есть хотябы одна ошибка - фейл
```

формальна FP.sequence
перобразует
`[ Result<Book.t, Error> ]`          список из монад Result
в
`Result< [Book.t], Error>`           монада Result над списком значений


Note: в Haskell список тоже является монадой


### Итоги

обсудили новый, более глубокий слой ФП состоящий из:
- монад, монадных трансформеров, каррированием

есть ФП языки, в которых эти вещи реализованы хорошо:
Haskell, Scala, OCaml, F#  (возможно Rust??)

в Elixir поддержка монад слабая
да подобный код на эликсире написать можно, на он будет не удобен в практическом
применении.
в Elixir для композиции ф-ий более удобно использовать
- оператор pipe (`|>`),
- макрос `with` (как раз для работа с разными монадами)
- функицю pipeline(Библиотека Plug)
- другие композции функций с монадами использовать в Эликсир просто не удобно
  оно не оч хорошо вписывается в дизайн языка.

Монады - совсем другой мир, или просто способ решения практических задач.
мир интересный, но увы не востребованный в комерческом программировании.

в истории программирования примерно в 70е годы была развилка в какую сторону
развиваться дальше.
70е годы время появляения большого кол-ва новых ЯП, как раз появлялось ФП, но
еще не существовало ООП. Но на то время код на ФП показывал заметно меньшую
производительность, чем императивные языки(к ним относиться язык Си)
а посколько ну то время комп-ры были слабые, ресурсы были дорогими - то выйграли
императивные языки, затем поверх него появилось обьектно ориентированное
программирование(ООП). А ФП ушло "в тень". Да прошло время и ФП вылезло из тени
и начало использоваться, но не на том уровне как могло бы быть.
Поэтому мир монад интересен, но не востребован в коммерческом программировании.

Для тех кому нравится ФП и мир монад, можно пойти и изучть такие продвинутые
ФП языки и даже найти команды и коммерческие проекты на таких языках, но это
будет достаточно сложно, поэтому копать эту тему слишком глубоко для практика
не особо перспективно. Цели данного и последующего курса - научить конкретным
практическим навыкам языка Эликсир. Эликсир - прикладной язык, который
применяется для прикладных задач в том числе в коммерческом программировании.
Тема же которую мы рассматрели скорее для расширения кургозора.

Эта тема закрывает первую часть данного курса.
Дальше будет курсовая работа.


