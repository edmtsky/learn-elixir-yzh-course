### Алгебраические типы данных

- ADT (Algebraic data type)
  это распостраннённое понятие в функци-м программировании

- Определённые операции над типами данных

- позволяют создавать новые типы

ADT - это про наличие неких операций, которые можно применять к одним типам
данных чтобы конструировать из них новые типы данных.



Алгебраические типы данных

Эти операции определены математически:
- произведение (умножение, product)
- сумма (перечисление, sum)


Вообще в алгебре есть четыре операции: +-*/
Для типов данных реализованы только две операции: *+
а такие операции как /- не раелизованы для типов данных

таким образом т.к. ADT это алгебраические операции, применяем некие
алгеброические действия к типам данных и умножая и складыва одни типы данных
получаем из них новые типы данных.
Поэтому это является алгеброй над типами данных.



Произведение

Самое простое произведение - это кортеж:
```elixir
{: event, title, place, time, participants, agenda }
```
(это обычный кортеж из языка Elixir, представляющий собой экземпляр сущности
модели "событие")


В языке OCaml тип кортежа так и обозначается - через знак умножения:
```ocaml
String * Place * DateTime * Participant list * Topic list
```
То есть по сути здесь мы как бы перемножаем все эти типы данных (соответствующие)
полям нужной нам структуры и в результате получаем новый тип данных Event
(который в эликсире мы просто представляем в виде кортежа)

(следующая реализация модели "Событие" на основе структур)

Произведение

Структура - это тоже произведение:

```elixir
event = %TS.Event{
  title: "Team Meeting",
  place: place,
  time: time,
  participants: participants,
  agenda: agenda
}
```
то есть семантически(по смыслу) это тоже самое
беруться типы данных(по нужным полям) и "умножаются" друг на друга и в результате
получаем новый тип данных `TS.Event` состоящий из всех полей структуры и их типов.


Сумма

на примерме Topic.priority
```elixir
defmodule Topic do
  @type t() :: %__MODULE__{
    subject: String.t(),
    priority: :high | :medium | :low,
  }
```

Здесь есть конечное множество значений для поля Topic.priority:
- :high
- :medium
- :low

(то есть значения этого поля могут быть равны только одному из указанных
вариантов и не могут быть равни ничему другому)

поэтому здесь говорял что происходит сумма значений:
 :high + :medium + :low --> новый тип для поля `priority` (множество)


Такое конечное множество значений обычно во многих языках называют Enum
(перечисление), Но в Эликсир нет таких перечислений и синтаксиса для его
определения.

Для Dialyzer в эликсире такой тип "перечисление" описывается вот так:

```elixir
@type priority :: :high | :medium | :low
#     1               2    3          4
```
- 1 - название итогового типа перечисления (в других языках, как java  Enum-а)
- 2,3,4 - набор(set) возможных значений данного перечисления.


В итоге у нас есть две операции над типами произведение(*) и сумма(+)
и через них можно конструировать новые типы данных.
- то есть через эти операции можно описать любые новые типы данных.


можно сказать что эти две операции над типами данных это новый уровень абстракции
позволяющий конструировать новые составные типы.

Раньше мы говорили о том, что для создания сколь угодно сложных вложенных и
развесистых значений достаточно только две сущности - кортежи и списки.
(Это про конструирование конкретных значений)

ADT (Algebraic data type) же - это уже про типы, а не значения. т.е. про
конструирование на уровне типов данных, а не просто некий значений.

Всё это теория из функционального программирования и Haskell в частности.
И для Elixr-разработчиков, может казаться что это не имеет никакого
практического значения. Эта теория больше для тех, кто создаёт новые языки и
компиляторы. Для них польза этой теории в том, чтобы компилятор мог создавать,
выводить и проверять разные типы данных.

ADT - это математический аппарат используемый при создании системы типов
в некоторых языках программировани, особенно в функциональных языках.


#### функциональные языки
у которых алгебраические типы данных(ADT) реализованы на уровне синтаксиса языка.

- Haskell
- OCaml
- Scala
- F#

такая реализация ADT на уровне языка даёт некоторые преимущества.


Пример приемуществ дающих ADT

- при применении pattern matching к типу Enum
проверяется, что в шаблонах использованы все возможные значения.
(то есть компилятор мог бы проверять код на это еще на этапе компиляции)
(Note - такого поведения нет в Elixir, но есть например в Rust)

```elixir
case topic.priority do
  :high -> do_something
  :medium -> do_something_else
  :low -> do_something_else_2
end
```

И если какого-то значения Enum-а не хватает то компилятор мог бы кидать ошибку
```elixir
case topic.priority do
  :high -> do_something
  :medium -> do_something_else
end
```
`не обработано значени :low`


такое поведение было бы очень полезно при активной разработке, когда в Enum
добавили новое значение и нужно чтобы компилятор помог подсветить все места
где нужно обновить всякие case-ветви с ним.

В Эликсир ни компилятор ни Dialyzer такие вещи (с обновлением значений
перечислений) отлавливать не умеет, поэтому либо ловить ошибки в рантайме.



### Что такое функциональное программирование?

это достаточно холиварная тема, здесь описано личное мнение автора это курса.

- не так просто ответить на этот вопрос.

проще было это сделать в 80-90годах когда были более чёткие границы между
функциональным и императивным программированием. На сегодняшний день эта граница
довольно размытая. И языки уже больше мультипарадигменные. Но вот про конкретный
написанный код можно однозначно сказать что он функциональный или нет.

ЯП традиционно относящиеся к ФП:

- Lisp         - прородитель всех функциональных языков
- Haskell      - самый строгий из всех ФП (разработан теоретиком)
- Standard ML
- OCaml
- Scala        - ФП из экосистемы JVM

это не все, но те которые точно можно назвать языками функционального программ.
Но даже эти языки не чисто ФП, по сути они мультипарадигменные -
то есть можно писать как функциональный так и императивный код и ООП-шный.

Scala - изначально создавался как мультипарадигменный, в нём есть и поддержка
ооп. тоже можно сказать и про OCaml.

А вот эти языки, которые изначально не поддерживали ФП
(топ 5 мейнстримовых языков)

- java
- C++
- Python
- JavaScript

но со временем эти языки позаимствовали много фишек из ФП.

то есть можно сказать что идёт перемешивание и размытие парадигм в рамках
даже одного языка.

Но вот сам код отличить является ли он ФП довольно легко.
и сделать это можно говоря о элементах функционального программирования.

> Элементы ФП

Для ФП характерно:
- Иммутабельные данные (Immutability)
- Рекурсяи, как основной способ итерации по коллекциям
- Функции высшего порядка (HOF) (можно передавать функции как значения)
- Анонимные функции (замыкания, лямбды)
- Алгебраические типы данных (ADT)
- Сопоставление с образцом (Pattern Matching)
- Ленивые вычисления (Lazy Evaluation)

и всё это есть в Эликсир.

Да это всё про теории, которую обычно рассказывают в самом начале базовых курсов.
Но знакомство с такой чистой теории вообще без какого либо практического
бэкграунда просто привело бы к тому что всё это бы не осело и не было бы понято
и осознанно как следует. А вот уже после того, как все вышеописанные вещи
опробованы самостоятельно на практике, это не просто пустые слова, а хорошо
знакомые концепции. А это значит то теория будет воспринята как надо.


#### что еще такое есть в ФП чего нет в эликсире

(еще элементы ФП:)

- Аавтоматический вывод типов (Type Inference)
- Чистые функции и контроль побочных эффектов

Поговорим по всем выше описанным элементам ФП


#### Иммутабельность

иммутабельные данные позволяют исключить определённый класс ошибок.
когда одна область в памяти модифицируется из разных мест в коде, или что еще
хуже из разных потоков(Threads) то есть из-за ошибок в многопоточности.
И эти ошибки обычно очень тяжело устранимы из-за того что их бывает практически
не возможно воспроизвести и отловить место их возникновения.

Иммутабельность
- исключает класс ошибок модификации данных из непонятных мест

- сильно упрощает многие аспекты разработки:
- многопоточку
- отладку
- статический анализ кода.

но есть конечно и своя цена которую приходится платить за иммутабельность:

поэтому прагматичные ЯП позволяют использовать иммутабельность там где это
действительно необходимо и другого выхода нет.
А Эрланг и Эликсир - прогматичные языки. То есть хотя языка иммутабельны, но
мутабельность есть на уровне виртуальной машины. И хотя на уровне языка данные
для нас иммутабельны, на уровне VM реализованы максимально эффективно, так что
по сути мутабельны. То есть при итерации коллекций через HOF на уровне языка
у нас полная иммутабельность, но под капотом на уровне VM(виртуальной машины)
такие операции обычно выполняются как обычные циклы в мутабельной памяти.


## Рекурсия

- итерация на основе рекурсии
  (а не на основе циклов как в императивных ЯП)

- абстракции поверх рекурсии - функции высшего порядка(HOF) map, filter, reduce

- ФП языки по части рекурсии и абстракции над ней, больше всего похожи друг с другом
  (то есть почти везде есть такие hof как: map, filter, reduce)
- хотя их названия и синтаксис может быть разными и сильно отличаться
  хотя при этом семантика(смысл суть) остаётся одна и та же везде.
  (принципы одни и те же, но выглядит по разному)


помним что есть хвоставая рекурсия
и вот эти вот функциональные фишки (такие функции как map, filter, reduce)
проникают и в другие языки программирования(Java, JS, и др)



#### Анонимные функции

- Анонимные ф-и и замыкания(closure) стоят рядом с HOF
  и добавляют удобства в разработке.

- Анонимные ф-и есть и не в ФП языках. но там они обычно выполняют другую роль
  например в JS анон. ф-и очень часто используются как коллбек(функция обратного
  вызова) в асинхронном коде, а не внутри map-reduce как это обычно в ФП языках.


#### Pattern Matching (Сопоставление с образцом)

- это способ разобрать развесистую структуру данных, на отдельные элементы
- это еще и способ организации условных переходов.

Это то, что обычно сильно отличает ФП код от императивного.
  - в императивном для переходов чаще используется if (cond) тогда как в ФП
    используется case + pattern-mattching
    в том же Эликсир if .., do end - это по сути просто максрос поверх `case`

Pattern Mattching - это один из элементов ФП, который не так стремительно и
просто проникает в императивные языки. Просто потому, что если изначально эта
фишка не заложена в архитектуре языка, то "приделать" её будет не так просто.
И да есть потуги сделать похоже, даже в том же Python, но это не тот паттерн
матчинг который есть у нас в Эликсире.


#### ADT - алгебраические типы данных

- это про моделирование сущностей и моделей нашей предметной области.

- четкое разделение данных от функций - это то что отличает ФП от ООП

В ООП обьекты это про состояние и методы обрабатывающие эти состояния,
тогда как в ФП данные отделены от функций их обрабатывающих.


####  Ленивые вычисления
- В Эликсир это модуль Stream и ленивые коллекции

- "ленивость" это визитка ФП языка Хаскель,
  в нём все вычисления прямо по умолчанию ленивые.
  Причем это заложено в самое основание языка.


#### Автоматический вывод типов
(этой фишки нет в Эликсир)

- ныне это есть во многих мейнстримовых языках - C++ и Java
- в 80-90е годы это было характерно для ФП, а в мейнстрим проникло позже.


#### Контроль побочных эффектов
это про чистые функции, которые не изменяют внешнее(глобальное) состояние,
а взаимодействуют только с значениями переданными им как параметры.
побочный эффект - это когда функция изменяет некое глобальное значение, которое
не передаётся ей как входные аргументы.

Наиболее известен этой фишкой язык Haskell - т.к. в нём эта вещь контролиуется
на уровне компилятора. А вот в других ЯП это лежит на плечах программистов.
То есть если программист хочет писать чистые функции - он берёт их и пишет,
и компилятор никак не проверяет его код на "чистоту функций".


#### Чистый код

- легче читать и понимать
- легче компоновать (переиспользовать с другим кодом)
- содержит меньше ошибок
  т.к. обычно трудно ошибки отлавливаемые ошибки возникают именно из-за побочных
  эффектов (т.к. "грязных" нечистых функций, изменяющие какое-то внешнее состояние)

В Эликсир чистый код пишется легко на уровне одного потока.
Можно придерживаться подхода принятого в Haskell - писать ядро системы чистым
кодом, а на перефирии системы (работа с БД и публичное API) оставлять "грязный код"

но вот писать многопоточность чистым кодом невозможно. А Эликсир это прежде всего
про многопоточность. Даже если разработчик пишет исключительно на феникс фреймворке
и "не видет" многопточки, то под копотом всё это работает именно через неё.

Но вот взаимодействие между потоками(эралнг-процессами) это уже побочный эффект.



#### Итог - отвечаем на вопрос что же такое ФП

- это код, состоящий в основном(80-90%) из элементов ФП
- хотя в нём могут быть не-ФП элементы:
- мутабельная память
- "настоящие" циклы for вместо рекурсии
- побочные эффекты

но таких элементов мало, и они добавляются в критических по производительности
местах.


