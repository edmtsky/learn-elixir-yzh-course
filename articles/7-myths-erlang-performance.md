# Семь мифов о производительности Эрланга

- The Seven Myths of Erlang Performance

[Оригинал](https://www.erlang.org/doc/efficiency_guide/myths.html)

Некоторые истины, кажется, живут намного дольше срока годности, возможно,
потому, что "информация" распространяется от человека к человеку быстрее,
нежели одиночное релиз-примечание, в котором говорится, например, что
вызовы на основе обычной рекурсии(body-recursion) стали быстрее.

Этот раздел пытается уничтожить старые истины (или полуправды), ставшие мифами.


## 1 Миф: функции с хвостовой рекурсией работают намного быстрее, чем с обычной

Согласно этому мифу, использование функции хвостовой рекурсии, которая строит
список в обратном порядке, с последующим вызовом `lists:reverse/1`, выполняется
быстрее, чем обычная-рекурсивная функиция, которая строит список в правильном
порядке; причина в том, что обычные рекурсивные функции используют больше памяти,
чем функции на основе хвостовой рекурсии.

В некоторой степени это было верно до `R12B`. Это было еще более верно до `R7B`.
Сегодня не так уж и много. Функция обычной рекурсии обычно использует тот же
объем памяти, что и функция с хвостовой рекурсией. Как правило, невозможно
заранее предугадать какой вариант рекурсии будет быстрее: хвостовой или обычной.
Поэтому используйте версию, которая делает ваш код чище
(подсказка: обычно это версия с обычной рекурсией (body-recursion)).


Более подробное обсуждение хвостовой и обычной рекурсии смотри в разделе
["Хвостовая рекурсия Эрланга - не серебряная пуля".](http://ferd.ca/erlang-s-tail-recursion-is-not-a-silver-bullet.html)


Заметка:
> Функция хвостовой рекурсии, которой не нужно инвертировать список в конце,
> работает быстрее, чем функция с обычной рекурсией, так же как и функции с
> хвостовой рекурсией, которые вообще не создают никаких значений (terms)
> (например, функция, которая суммирует все целые числа в списоке).


## 2 Миф: оператор "++" всегда плох

Оператор `++` несколько незаслуженно получил плохую репутацию. Вероятно, это
как-то связано с кодом, подобным следующему, который является наиболее
неэффективным способом перевернуть список:


### DO NOT

```erlang
naive_reverse([H|T]) ->
    naive_reverse(T)++[H];
naive_reverse([]) ->
    [].
```

Поскольку оператор `++` копирует свой левый операнд, результат копируется
повторно, что приводит к квадратичной сложности(complexity).

Но использовать `++` следующим образом неплохо:

### OK

```erlang
naive_but_ok_reverse([H|T], Acc) ->
    naive_but_ok_reverse(T, [H]++Acc);
naive_but_ok_reverse([], Acc) ->
    Acc.
```

Каждый элемент списка копируется только один раз. Растущий результат `Acc`
является правым операндом для оператора `++` и не копируется.


Опытные Erlang-программисты написали бы следующее:

### DO

```erlang
vanilla_reverse([H|T], Acc) ->
    vanilla_reverse(T, [H|Acc]);
vanilla_reverse([], Acc) ->
    Acc.
```

Это немного более эффективно, поскольку здесь не создается элемент списка
только для его прямого копирования. (Или было бы более эффективно, если бы
компилятор не переписывал автоматически `[H]++Acc` на `[H|Acc]`.)


## 3 Миф: Строки медленные

Обработка строк может быть медленной, если делается неправильно. В Erlang нужно
немного больше продумать то, как используются строки, и выбрать подходящее
представление. Если вы используете регулярные выражения, используйте модуль
[re](https://www.erlang.org/doc/man/re) в STDLIB вместо устаревшего модуля `regexp`.


## Миф 4: восстановление Dets-файла происходит очень медленно

Время восстановления по-прежнему пропорционально количеству записей в файле, но
раньше восстановление Dets было намного медленнее.
Dets был значительно переписан и улучшен.

[depts](https://www.erlang.org/doc/man/dets.html)


## Миф 5: BEAM - это виртуальная машина с байт-кодом на основе стека (а значит медленная)

`BEAM` - это виртуальная машина на основе регистров.
`BEAM` имеет 1024 виртуальных регистра, которые используются для хранения
временных значений и передачи аргументов при вызове функций. Переменные, которым
необходимо пережить вызов функции, сохраняются в стек.

`BEAM` - это интерпретатор многопоточного кода. Каждая инструкция представляет
собой слово, указывающее непосредственно на исполняемый C-код, что делает
диспетчеризацию инструкций очень быстрой.


## Миф 6: используйте "_" для ускорения программы, когда переменная не используется

Когда-то это было правдой, но начиная с `R6B` компилятор BEAM видит, что
переменная не используется.

Точно так же тривиальные преобразования на уровне исходного кода, такие как
преобразование `case`-оператора в верхоуровневые тела функции(clauses),
редко оказывают какое-либо влияние на сгенерированный код.


## 7 Миф: NIF всегда ускоряет вашу программу

Переписывание Erlang-кода в NIF для ускорения его работы следует рассматривать
как последнее средство. Гарантировано это даст только опасность, но не будет
гарантировать ускорение работы программы.

Выполнение слишком большого объема работы, при каждом вызове NIF, ухудшит
скорость реагирования виртуальной машины. Выполнение слишком малого объема
работы может означать, что выигрыш от более быстрой NIF-обработки будет съеден
накладными расходами на NIF-вызовы и проверки аргументов.

Обязательно прочитайте о долго-живущих NIF, прежде чем писать NIF.

[NIF](https://www.erlang.org/doc/tutorial/nif.html)

