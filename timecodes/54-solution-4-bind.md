00:30 вводная что будем делать
01:10 fp.ex модуль для реализации FP-шные фишек которых нет в Elixir
01:26 выход на оператор bind и monada result
03:23 пишем bind-функцию аналог bind в Haskell
05:42 испытываем наш bind на простейшем практическом примере (композиция из 2х)
07:36 делаем композицию из 3х функций
08:17 испытываем остановку вызовов в композиции функций
08:45 как тот же код выглядил бы на Haskell
09:15 первая засада для написания solution-4 используя bind
10:36 функции обёртки для прогона state по цепочке композиции ф-ий
10:48 приступаем к реализации solution-4
16:47 собираем обёртки шагов валидации через bind в цепочку
18:30 проверяем реализацию solution-4, руками через консоль и через тесты
19:28 сравниваем solution-4 и solution-2
21:00 копаем теорию ФП глубже: формализация FP.bind прописываем типы
23:09 выход на sequence из Haskell
24:56 пишем свою реализацию sequence из Haskell
27:11 переписываем solution-4 на использование свой реализации sequence
28:38 подводим итог освоенных продвинутых ФП-фишек
29:10 да solution-4 уже получше но далёк от идеала, есть что улучшать.

