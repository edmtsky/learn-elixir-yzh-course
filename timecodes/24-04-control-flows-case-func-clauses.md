00:48 отличие Функциональных от императивных языков программирования
02:42 подробное рассмотрение ветвления в коде (control flow)
02:45 конструкция case в общем виде
03:36 упражнение 2 уровня ветвления и 6 разных веток кода (домашние животные)
07:03 запускаем код нового модуля в iex-оболочке
07:14 создание короткого псевдонима для полного имени модуля
08:40 недостаток вложенной case-конструкции
09:20 упрощаем код case-структуры. Один case проверяющий сразу два значения
11:37 о достоинствах плоской case-структуры(1 уровень вложенности)
11:55 ошибка в case когда есть неучтённые ветви исполнения CaseClauseError
12:24 ветвления через тела функций (clause)
13:34 одна функция handle3 с четырьмя телами. Как это работает.
      сопоставление по аргументам функции
14:01 проверяем тела функций в действии (iex)
15:12 взаимозаменяемость тел функций и case-ветвлений
15:24 FunctionClauseError ошибка когда есть неучтённые аргументы для функции
      когда значения входящих аргументов не совпадают ни с одним описанным шаблоном
15:45 о важности порядка описания шаблонов сопоствления в телах функций
16:38 предупреждения от компилятора при ошибочном построении шаблонов для функций
16:57 о проблеме clause cannot match because a previous clause always matches
17:18 более широкие шаблоны перехватывают более узкие шаблоны.(О порядке шаблонов)
17:29 о важности очередности шаблонов. как исправлять `always matches`
18:25 тонкость работы компилятора при определении более широких и узких шаблонов.
20:37 шаблон "catch all"
21:52 делаем более специализированный шаблон для проверки валидности структуры данных
22:46 best practice с написанием "catch all"-шаблонов. только валидные данные.

