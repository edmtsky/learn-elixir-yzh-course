### Курсовой проект Work Report. Постановка задачи

README.md - описано что именно нужно сделать в корсовом.
примерное время реализации
- опытный Elixir разработчик ~ 2 часа
- начинающий Elixir разработчик 4+ часа

Цель - применить на практике все полученные навыки

Задача:
реализовать консольную(cli) утилиту которая
- получает на вход некий текстовый файл и обрабатывает его.

обоснование
(что за утилита)
- ведём отчёт о проделанной работе.
  есть месяц, день и делаем записи чем занимались это день.

есть концепция TODO - менеджер списка задач которые надо сделать
в данном случае это DONE лист того что уже сделано и сколько оно заняло времени.

нужна консольная утилита для получения аналитики по входным данным (файлу)
и нужны возможность узнать
- сколько отработано за день
- сколько отработали по каждой категории DEV, COMM, OPS, DOC
- за текущий день, за конкретный день, за месяц
- какая производительность в день

парсер и сущности предметной области

нужен парсер, который способен распарсить входной текст(markdown) превратив
тескт в сущности предметной области.
нужно продумать какие нужны модели (сущности предметной области)

сущность задача, в ней
пример
`[DEV] Task-44 Implement - 52m`

 - категория, описание, потреченное время

есть сущность "отчёт за день":
```markdown
## 5 wed
[DEV] Review Pull Request - 39m
[DEV] Task-44 Implement - 52m
...
```
- число (день месяца)
- список задач выполненных в этот день

есть сущность месяц
- список сущностей отчёты-за-день

сущность "отчёт" для вывода внутри форматера

нужно придумать модель, расписать сущности используя то что удобно
(Map, Struct урок про моделирование предметной области)

задача парсера - принять markdown текст и выдать сущности предментной области
причем по ходу дела добавляя создавая свои юнит-тесты для парсера и форматтера

задача форматтера - выводить сущности в читабельном текстовом виде

### о интеграционных тестах
test/integration_test.exs
как работает интеграционный тест
- реализованный скрипт собирается в исполняемый файл
- дальше интеграционный тест:
  - запускает исполняемый файл
  - передаёт на вход бинаря некий markdown отчёт указывая некие аргументы
  - и ожидает получить некий ответ


что уже подготовлено и работает из коробки:
lib/work_report.ex - это точка входа в cli утилиту, которая будет собираться
в исполняемый бинарь. здесь реализован парсинг cli аргументов и вывод справки.

чтобы собрать бинарник:
```sh
mix deps.get
mix escript.build
```

```sh
./work_report
USAGE
    work_report [OPTION] <path/to/report.md>
OPTIONS:
    -m, --month <M> ...
```
```sh
./workreport -h
USAGE...

./workreport -v
Work Report v1.0.0

./workreport -m 5 -d 1 test/samle/report-2.md
... пусто т.к. пока нет никакой реализации
```


###  место в коде откуда начинается собственная работа

```elixir
def do_report(params, _file) do
  _month = Map.get(params, :month, :erlang.date() |> elem(1))
  _day = Map.get(params, :day, :erlang.date() |> elem(2))

  # TODO your immplementation here
  # здесь нужно
  # - распарсить файл, создать обьекты предметной области
  # - сделать запрос к созданным в памяти данным
  # - вывести нужную статистику в виде текста
end
```

- _file - путь к файлу который нужно распарсить

рекомендуется самостоятельно решить данную курсовую
критерий правильности - проходят интеграционные тесты
тех кто сам решит данную курсовую работу можно оценивать даже не как junior
Elixir-developer а как начинающего middle-а




